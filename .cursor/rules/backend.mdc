---
description:
globs:
alwaysApply: true
---
# 后端开发规范

本文档整合了后端服务开发、Node.js规范和脚本开发相关的规范，为后端开发提供全面指导。

## 后端服务开发规范

### API设计

- 遵循RESTful API设计原则
- 使用适当的HTTP方法和状态码
- 实现统一的错误处理和响应格式
- API路径使用kebab-case命名
- 编写清晰的API文档

### 数据库规范

- MongoDB模型定义清晰，包含适当的验证规则
- 创建必要的索引提高查询性能
- 设计合理的模型关系
- 总是处理数据库操作错误
- 使用事务保证数据一致性

### 数据库操作

- 避免在代码中硬编码数据库连接信息
- 使用环境变量管理数据库连接字符串(`MONGODB_URL`)

### 统一响应格式

```typescript
// API响应格式示例
export interface IApiResponse<T> {
  code: number;
  data: T;
  message: string;
}

// 使用示例
return {
  code: 200,
  data: user,
  message: '获取成功'
};
```

### 错误处理

- 使用try/catch捕获所有异步操作可能的错误
- 实现统一的错误处理中间件
- 为不同类型的错误定义适当的状态码和错误消息
- 记录关键错误日志，但不暴露敏感信息给客户端

```typescript
// 错误处理示例
try {
  const user = await db.findUser(id);
  if (!user) {
    return {
      code: 404,
      data: null,
      message: '用户不存在'
    };
  }
  return {
    code: 200,
    data: user,
    message: '获取成功'
  };
} catch (error) {
  console.error('获取用户失败:', error);
  return {
    code: 500,
    data: null,
    message: '服务器内部错误'
  };
}
```

## Node.js 规范

- 在使用 process 的时候总是使用 `import * as process from 'node:process'`
- 所有Node.js内置模块导入都使用`node:`前缀
  ```typescript
  // 正确示例
  import * as fs from 'node:fs/promises';
  import * as path from 'node:path';
  import * as http from 'node:http';

  // 错误示例
  import * as fs from 'fs/promises';
  ```
- 优先使用Node.js提供的稳定API，避免使用实验性API
- 使用环境变量管理配置，而不是硬编码
- 使用async/await处理异步操作，避免回调地狱
- 使用错误优先的回调风格处理传统回调API

### 文件系统操作

- 优先使用promises API而非回调式API
  ```typescript
  // 推荐
  import * as fs from 'node:fs/promises';

  async function readFile() {
    try {
      const content = await fs.readFile('./config.json', 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      console.error('读取文件失败:', error);
      throw error;
    }
  }
  ```
- 使用相对路径时，使用`path.resolve`或`path.join`确保跨平台兼容性
- 总是处理文件操作的异常

### 进程管理

- 为长时间运行的服务实现优雅退出
- 监听并处理进程信号（SIGTERM、SIGINT等）
- 使用`uncaughtException`和`unhandledRejection`捕获全局错误，但仅用于记录日志和优雅退出
- 避免在这些事件中恢复应用程序状态

```typescript
import * as process from 'node:process';

// 处理未捕获的异常
process.on('uncaughtException', (error) => {
  console.error('未捕获异常:', error);
  // 记录错误后优雅退出
  process.exit(1);
});

// 处理未处理的Promise拒绝
process.on('unhandledRejection', (reason, promise) => {
  console.error('未处理的Promise拒绝:', reason);
  // 可以选择不退出，但要记录错误
});

// 处理终止信号
process.on('SIGTERM', () => {
  console.log('收到SIGTERM信号，开始优雅退出...');
  // 关闭服务器、数据库连接等
  // ...
  process.exit(0);
});
```

## 脚本开发规范

### 基本原则

- 总是以 node 来书写脚本保证跨平台属性
- 所有脚本文件使用TypeScript编写，通过tsx执行
- 使用ES Module语法(import/export)
- Node.js内置模块使用node:前缀导入
- 为所有函数添加类型注解和JSDoc注释
- 异步函数返回类型使用Promise<T>
- 使用async/await处理异步代码

### 文件组织

- 脚本文件使用.ts扩展名
- 使用kebab-case命名文件（例如：test-mongodb-connection.ts）
- 每个文件名应当清晰表达其功能
- 脚本文件头部添加描述注释，包含作者、日期和用途

### 代码风格

- 使用单引号定义字符串
- 语句结尾使用分号
- 缩进使用2个空格
- 变量和函数使用camelCase命名
- 类型和接口使用PascalCase命名
- 常量使用UPPER_SNAKE_CASE命名
- 布尔类型的变量使用is开头

### 脚本示例

```typescript
/**
 * 数据库连接测试脚本
 *
 * 作者: aiftt
 * 创建日期: {date}
 * 用途: 测试MongoDB连接并验证基本操作
 */
import * as process from 'node:process';
import { MongoClient, ServerApiVersion } from 'mongodb';

// 从环境变量获取连接字符串，避免硬编码
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const DB_NAME = process.env.DB_NAME || 'test_database';

/**
 * 测试MongoDB连接
 * @returns {Promise<boolean>} 连接测试结果
 */
async function testConnection(): Promise<boolean> {
  const client = new MongoClient(MONGODB_URI, {
    serverApi: {
      version: ServerApiVersion.v1,
      strict: true,
      deprecationErrors: true,
    }
  });

  try {
    // 连接到MongoDB
    await client.connect();

    // 测试ping命令
    await client.db('admin').command({ ping: 1 });
    console.log('MongoDB连接成功！');

    // 测试基本CRUD操作
    const db = client.db(DB_NAME);
    const collection = db.collection('test_collection');

    // 插入测试文档
    const insertResult = await collection.insertOne({
      test: true,
      createdAt: new Date()
    });
    console.log('插入测试文档成功:', insertResult.insertedId);

    // 查询测试文档
    const foundDocument = await collection.findOne({ _id: insertResult.insertedId });
    console.log('查询测试文档:', foundDocument);

    // 删除测试文档
    await collection.deleteOne({ _id: insertResult.insertedId });
    console.log('删除测试文档成功');

    return true;
  } catch (error) {
    console.error('MongoDB连接测试失败:', error);
    return false;
  } finally {
    await client.close();
    console.log('MongoDB连接已关闭');
  }
}

/**
 * 主函数
 */
async function main(): Promise<void> {
  try {
    const isSuccess = await testConnection();
    process.exit(isSuccess ? 0 : 1);
  } catch (error) {
    console.error('脚本执行失败:', error);
    process.exit(1);
  }
}

// 执行主函数
main().catch(error => {
  console.error('未捕获错误:', error);
  process.exit(1);
});
```

### 命令行参数处理

```typescript
import * as process from 'node:process';

/**
 * 解析命令行参数
 * @returns {Record<string, string>} 解析后的参数对象
 */
function parseArgs(): Record<string, string> {
  const args: Record<string, string> = {};

  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];

    // 处理 --key=value 格式
    if (arg.startsWith('--')) {
      const [key, value] = arg.substring(2).split('=');
      if (key && value) {
        args[key] = value;
      }
    }
    // 处理 -k value 格式
    else if (arg.startsWith('-') && i + 1 < process.argv.length) {
      const key = arg.substring(1);
      const nextArg = process.argv[i + 1];

      if (!nextArg.startsWith('-')) {
        args[key] = nextArg;
        i++; // 跳过下一个参数
      }
    }
  }

  return args;
}

// 使用示例
const args = parseArgs();
console.log('解析的参数:', args);
```

### 文件处理规范

- 使用流式处理大文件，避免一次性读取导致内存问题
- 处理所有I/O操作的错误情况
- 使用临时文件时确保正确清理
- 文件路径使用path模块处理，确保跨平台兼容性

```typescript
import * as fs from 'node:fs/promises';
import * as path from 'node:path';

/**
 * 安全地创建目录（如果不存在）
 * @param {string} dirPath 目录路径
 * @returns {Promise<void>}
 */
async function ensureDir(dirPath: string): Promise<void> {
  try {
    await fs.access(dirPath);
  } catch {
    // 目录不存在，创建它
    await fs.mkdir(dirPath, { recursive: true });
    console.log(`创建目录: ${dirPath}`);
  }
}

/**
 * 安全地保存JSON数据到文件
 * @param {string} filePath 文件路径
 * @param {any} data 要保存的数据
 * @returns {Promise<void>}
 */
async function saveJsonToFile(filePath: string, data: any): Promise<void> {
  // 确保目录存在
  const dirPath = path.dirname(filePath);
  await ensureDir(dirPath);

  // 先写入临时文件，再重命名，防止写入中断导致文件损坏
  const tempFilePath = `${filePath}.temp`;

  try {
    // 使用漂亮的格式化
    const jsonContent = JSON.stringify(data, null, 2);
    await fs.writeFile(tempFilePath, jsonContent, 'utf-8');
    await fs.rename(tempFilePath, filePath);
    console.log(`成功保存文件: ${filePath}`);
  } catch (error) {
    console.error(`保存文件失败: ${filePath}`, error);
    // 清理临时文件
    try {
      await fs.unlink(tempFilePath);
    } catch {
      // 忽略删除临时文件的错误
    }
    throw error;
  }
}
```
